{"version":3,"file":"parse.js","sourceRoot":"","sources":["../src/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import { tokenise } from \"./tokenise\";\nimport { PACKABLE_TYPES, TokenCount, on_syntax_version, on_package_name, on_enum, on_message, on_option, on_import, on_extend, on_service, Lookup, LookupIn } from \"./parser-internals\";\nimport { Schema } from \"./schema\";\n\ninterface ToString {toString(): string;}\nexport function parse<T extends ToString>(from: T) {\n\tconst schema = new Schema\n\tconst lu: Lookup = []\n\tschema_parse: {\n\t\tconst tc = new TokenCount(Object.freeze(tokenise(from.toString())))\n\t\twhile (!tc.done) switch (tc.peek()) {\n\t\t\tcase 'syntax':\n\t\t\t\tif (tc.t !== 0)\n\t\t\t\t\ttc.syntax_err('Protobuf syntax version must be first token in file');\n\t\t\t\ton_syntax_version(schema, tc);\n\t\t\t\tbreak;\n\t\t\tcase 'package': on_package_name(schema, tc); break;\n\t\t\tcase 'enum': on_enum(schema, tc, lu); break;\n\t\t\tcase 'message': on_message(schema, tc, lu); break;\n\t\t\tcase 'option':\n\t\t\t\ton_option(schema, tc);\n\t\t\t\tif (schema.options.has(\"optimize_for\")) {\n\t\t\t\t\tlet optimize_for = schema.options.get(\"optimize_for\")\n\t\t\t\t\tswitch (optimize_for) {\n\t\t\t\t\t\tcase 'SPEED': case 'CODE_SIZE': case 'LITE_RUNTIME':\n\t\t\t\t\t\t\tschema.optimize_for = optimize_for;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'import': on_import(schema, tc); break;\n\t\t\tcase 'extend': on_extend(schema, tc, lu); break;\n\t\t\tcase 'service': on_service(schema, tc); break;\n\t\t\tdefault: throw new SyntaxError(`Unexpected token: ${tc.next()}`)\n\t\t}\n\t}\n\n\tschema_extend: for (const ext of schema.extends) for (const msg of schema.messages) if (msg.name === ext.name) for (const field of ext.msg.fields) {\n\t\tif (!msg.extensions || field.tag < msg.extensions.from || field.tag > msg.extensions.to)\n\t\t\tthrow new ReferenceError(`${msg.name} does not declare ${field.tag} as an extension number`)\n\n\t\tmsg.fields.push(field)\n\t}\n\tschema_pack: for (const msg of schema.messages) for (const field of msg.fields) if (field.packed && !PACKABLE_TYPES.includes(field.type)) {\n\t\t// check enum type\n\t\ttype LUE = LookupIn<'enum'> | undefined;\n\t\tlet type = lu.find(f => f.name === field.type && f.is === 'enum') as LUE\n\t\tif (type) continue\n\t\telse if (field.type.includes('.')) {\n\t\t\tconst types = field.type.split('.')\n\t\t\tlet last = types.pop()\n\t\t\tconst mfind = (f: typeof lu[0]) => f.name === last && f.is === 'enum'\n\t\t\tlet curr = lu.find(mfind) as LUE\n\t\t\tif (curr) while (types.length && curr) {\n\t\t\t\tlast = `${types.pop()!}.${last}`\n\t\t\t\tlet c = lu.find(mfind) as LUE\n\t\t\t\tif (c && curr.value === c.value) curr = c\n\t\t\t}\n\n\t\t\tif (!curr)\n\t\t\t\tthrow new ReferenceError(`Cannot find field type ${field.type}`)\n\n\t\t\tif (curr) continue\n\t\t}\n\t\telse if (msg.enums.some(en => en.name === field.type)) continue;\n\t\telse if (schema.enums.some(en => en.name === field.type)) continue;\n\n\t\tthrow new SyntaxError(`Fields of type ${field.type} cannot be declared [packed=true]. Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire types) can be declared as \"packed\". See https://developers.google.com/protocol-buffers/docs/encoding#optional`)\n\t}\n\treturn schema\n}\nexport default parse\n"]}