{"version":3,"file":"parse.js","sourceRoot":"","sources":["../src/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import { tokenise } from \"./tokenise\";\nimport { PACKABLE_TYPES, TokenCount, on_syntax_version, on_package_name, on_enum, on_message, on_option, on_import, on_extend, on_service, Lookup, LookupIn, Enum, Message, Extends } from \"./parser-internals\";\nimport { Schema } from \"./schema\";\nexport { Schema } from \"./schema\";\nconst exported_lookups = new WeakMap<Schema, Lookup>();\nexport function find_lookup(s: Schema, name: string, is: \"enum\"): Enum\nexport function find_lookup(s: Schema, name: string, is: \"message\"):Message\nexport function find_lookup(s: Schema, name: string, is: \"extends\"): Extends\nexport function find_lookup(schema: Schema, fname: string, fis: \"enum\" | \"message\" | \"extends\") {\n\tif (!schema.package) throw new SyntaxError(`cannot take schemas without a package name`)\n\tlet v = exported_lookups.get(schema)!\n\t.find(({is, name}) => is === fis && fname === name)!\n\tswitch (fis) {\n\t\tcase \"enum\": return v.value as Enum;\n\t\tcase \"message\": return v.value as Message;\n\t\tcase \"extends\": return v.value as Extends;\n\t}\n}\ninterface ToString {toString(): string;}\nexport function parse<T extends ToString>(from: T) {\n\tconst schema = new Schema\n\tconst lu: Lookup = []\n\tconst exported: Lookup = [];\n\tschema_parse: {\n\t\tconst tc = new TokenCount(Object.freeze(tokenise(from.toString())))\n\t\twhile (!tc.done) switch (tc.peek()) {\n\t\t\tcase 'syntax':\n\t\t\t\tif (tc.t !== 0)\n\t\t\t\t\ttc.syntax_err('Protobuf syntax version must be first token in file');\n\t\t\t\ton_syntax_version(schema, tc);\n\t\t\t\tbreak;\n\t\t\tcase 'package': on_package_name(schema, tc); break;\n\t\t\tcase 'enum': on_enum(schema, tc, lu); break;\n\t\t\tcase 'message': on_message(schema, tc, lu); break;\n\t\t\tcase 'option':\n\t\t\t\ton_option(schema, tc);\n\t\t\t\tif (schema.options.has(\"optimize_for\")) {\n\t\t\t\t\tlet optimize_for = schema.options.get(\"optimize_for\")\n\t\t\t\t\tswitch (optimize_for) {\n\t\t\t\t\t\tcase 'SPEED': case 'CODE_SIZE': case 'LITE_RUNTIME':\n\t\t\t\t\t\t\tschema.optimize_for = optimize_for;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'import': on_import(schema, tc); break;\n\t\t\tcase 'extend': on_extend(schema, tc, lu); break;\n\t\t\tcase 'service': on_service(schema, tc); break;\n\t\t\tdefault: throw new SyntaxError(`Unexpected token: ${tc.next()}`)\n\t\t}\n\t}\n\n\tschema_extend: for (const ext of schema.extends) for (const msg of schema.messages) if (msg.name === ext.name) for (const field of ext.msg.fields) {\n\t\tif (!msg.extensions || field.tag < msg.extensions.from || field.tag > msg.extensions.to)\n\t\t\tthrow new ReferenceError(`${msg.name} does not declare ${field.tag} as an extension number`)\n\n\t\tmsg.fields.push(field)\n\t}\n\tschema_pack: for (const msg of schema.messages) for (const field of msg.fields) if (field.packed && !PACKABLE_TYPES.includes(field.type)) {\n\t\t// check enum type\n\t\ttype LUE = LookupIn<'enum'> | undefined;\n\t\tlet type = lu.find(f => f.name === field.type && f.is === 'enum') as LUE\n\t\tif (type) continue\n\t\telse if (field.type.includes('.')) {\n\t\t\tconst types = field.type.split('.')\n\t\t\tlet last = types.pop()\n\t\t\tconst mfind = (f: typeof lu[0]) => f.name === last && f.is === 'enum'\n\t\t\tlet curr = lu.find(mfind) as LUE\n\t\t\tif (curr) while (types.length && curr) {\n\t\t\t\tlast = `${types.pop()!}.${last}`\n\t\t\t\tlet c = lu.find(mfind) as LUE\n\t\t\t\tif (c && curr.value === c.value) curr = c\n\t\t\t}\n\n\t\t\tif (!curr)\n\t\t\t\tthrow new ReferenceError(`Cannot find field type ${field.type}`)\n\n\t\t\tif (curr) continue\n\t\t}\n\t\telse if (msg.enums.some(en => en.name === field.type)) continue;\n\t\telse if (schema.enums.some(en => en.name === field.type)) continue;\n\n\t\tthrow new SyntaxError(`Fields of type ${field.type} cannot be declared [packed=true]. Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire types) can be declared as \"packed\". See https://developers.google.com/protocol-buffers/docs/encoding#optional`)\n\t}\n\tif (schema.package) {\n\t\tfor (const {name, is, value} of lu) exported.push({\n\t\t\tname: `${schema.package}.${name}`,\n\t\t\tis, value\n\t\t})\n\t\texported_lookups.set(schema, exported)\n\t}\n\treturn schema\n}\nexport default parse\n"]}