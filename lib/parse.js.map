{"version":3,"file":"parse.js","sourceRoot":"","sources":["../src/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import { tokenise } from \"./tokenise\";\nimport { PACKABLE_TYPES, TokenCount, onSyntaxVersion, onPackageName, onEnum, onMessage, onOption, onImport, onExtend, onService, Message } from \"./parser-internals\";\nimport { Schema } from \"./schema\";\n\ntype parserInternal = (schema: Schema, n: TokenCount) => void;\ninterface ToString {toString(): string;}\nexport function parse<T extends ToString>(from: T) {\n\tconst tc = new TokenCount(Object.freeze(tokenise(from.toString())))\n\tconst schema = new Schema\n\tconst call: ((v: parserInternal)=>void) = v => v(schema, tc);\n\twhile (!tc.done) switch (tc.peek()) {\n\t\tcase 'syntax':\n\t\t\tif (tc.t !== 0)\n\t\t\t\tthrow new SyntaxError('Protobuf syntax version must be first token in file');\n\t\t\tcall(onSyntaxVersion);\n\t\t\tbreak;\n\t\tcase 'package': call(onPackageName); break;\n\t\tcase 'enum': call(onEnum); break;\n\t\tcase 'message': call(onMessage); break;\n\t\tcase 'option':\n\t\t\tcall(onOption);\n\t\t\tif (schema.options.has(\"optimize_for\")) {\n\t\t\t\tlet optimize_for = schema.options.get(\"optimize_for\")\n\t\t\t\tswitch (optimize_for) {\n\t\t\t\t\tcase 'SPEED': case 'CODE_SIZE': case 'LITE_RUNTIME':\n\t\t\t\t\t\tschema.optimize_for = optimize_for;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'import': call(onImport); break;\n\t\tcase 'extend': call(onExtend); break;\n\t\tcase 'service': call(onService); break;\n\t\tdefault: throw new SyntaxError(`Unexpected token: ${tc.next()}`)\n\t}\n\n\tfor (const ext of schema.extends) for (const msg of schema.messages) {\n\t\tif (msg.name === ext.name) for (const {fields} of ext.messages) for (const field of fields) {\n\t\t\tif (!msg.extensions || field.tag < msg.extensions.from || field.tag > msg.extensions.to)\n\t\t\t\tthrow new ReferenceError(`${msg.name} does not declare ${field.tag} as an extension number`)\n\n\t\t\tmsg.fields.push(field)\n\t\t}\n\t}\n\tfor (const msg of schema.messages) for (const field of msg.fields) {\n\t\tif (field.packed && !PACKABLE_TYPES.includes(field.type)) {\n\t\t\t// check enum type\n\t\t\tif (field.type.includes('.')) {\n\t\t\t\tconst types = field.type.split('.')\n\t\t\t\tlet last = types.shift(), curr: Message | undefined = schema.messages.find(v => v.name === last)\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tif (curr) curr = curr.messages.find(v => v.name === type)\n\t\t\t\t\tif (curr) last = type\n\t\t\t\t}\n\n\t\t\t\tif (!curr)\n\t\t\t\t\tthrow new ReferenceError(`Cannot find field type ${field.type}`)\n\n\t\t\t\tif (curr) continue\n\t\t\t} else if (msg.enums.some(en => en.name === field.type)) continue;\n\n\t\t\tthrow new SyntaxError(`Fields of type ${field.type} cannot be declared [packed=true]. Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire types) can be declared as \"packed\". See https://developers.google.com/protocol-buffers/docs/encoding#optional`)\n\t\t}\n\t}\n\treturn schema\n}\n"]}