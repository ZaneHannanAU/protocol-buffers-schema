{"version":3,"file":"parse.js","sourceRoot":"","sources":["../src/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import { tokenise } from \"./tokenise\";\nimport { PACKABLE_TYPES, TokenCount, on_syntax_version, on_package_name, on_enum, on_message, on_option, on_import, on_extend, on_service, Lookup, Enum, Message, Extends, MAP_KEY_TYPES } from \"./parser-internals\";\nimport { Schema } from \"./schema\";\nexport { Schema } from \"./schema\";\nconst exported_lookups = new WeakMap<Schema, Lookup>();\nexport function find_lookup(s: Schema, name: string, is: \"enum\"): Enum | undefined\nexport function find_lookup(s: Schema, name: string, is: \"message\"): Message | undefined\nexport function find_lookup(s: Schema, name: string, is: \"extends\"): Extends | undefined\nexport function find_lookup(schema: Schema, fname: string, fis: \"enum\" | \"message\" | \"extends\") {\n\tlet v = exported_lookups.get(schema)!\n\t.find(({is, name}) => is === fis && fname === name)\n\tif (!v) return undefined\n\tswitch (fis) {\n\t\tcase \"enum\": return v.value as Enum;\n\t\tcase \"message\": return v.value as Message;\n\t\tcase \"extends\": return v.value as Extends;\n\t}\n}\nexport function find_lookups(s: Schema, is: \"enum\"): IterableIterator<Enum>\nexport function find_lookups(s: Schema, is: \"message\"): IterableIterator<Message>\nexport function find_lookups(s: Schema, is: \"extends\"): IterableIterator<Extends>\nexport function* find_lookups(schema: Schema, fis: \"enum\" | \"message\" | \"extends\") {\n\tlet prev = new WeakSet\n\tfor (const {is, value} of exported_lookups.get(schema)!)\n\t\tif (is === fis && !prev.has(value)) {prev.add(value); yield value}\n}\ninterface ToString {toString(): string;}\nexport function parse<T extends ToString>(from: T) {\n\tconst schema = new Schema\n\tconst lu: Lookup = []\n\texported_lookups.set(schema, lu)\n\tschema_parse: {\n\t\tconst tc = new TokenCount(Object.freeze(tokenise(from.toString())))\n\t\twhile (!tc.done) switch (tc.peek()) {\n\t\t\tcase 'syntax':\n\t\t\t\tif (tc.t !== 0)\n\t\t\t\t\ttc.syntax_err('Protobuf syntax version must be first token in file');\n\t\t\t\ton_syntax_version(schema, tc);\n\t\t\t\tbreak;\n\t\t\tcase 'package': on_package_name(schema, tc); break;\n\t\t\tcase 'enum': on_enum(schema, tc, lu); break;\n\t\t\tcase 'message': on_message(schema, tc, lu); break;\n\t\t\tcase 'option':\n\t\t\t\ton_option(schema, tc);\n\t\t\t\tif (schema.options.has(\"optimize_for\")) {\n\t\t\t\t\tlet optimize_for = schema.options.get(\"optimize_for\")\n\t\t\t\t\tswitch (optimize_for) {\n\t\t\t\t\t\tcase 'SPEED': case 'CODE_SIZE': case 'LITE_RUNTIME':\n\t\t\t\t\t\t\tschema.optimize_for = optimize_for;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'import': on_import(schema, tc); break;\n\t\t\tcase 'extend': on_extend(schema, tc, lu); break;\n\t\t\tcase 'service': on_service(schema, tc); break;\n\t\t\tdefault: throw new SyntaxError(`Unexpected token: ${tc.next()}`)\n\t\t}\n\t}\n\tmap_types: for (const {value} of lu) {\n\t\tif (value instanceof Message || value instanceof Extends) for (const field of value.fields) if (field.map) {\n\t\t\tif (MAP_KEY_TYPES.includes(field.map.from) ||\n\t\t\t\tfind_lookup(schema, field.map.from, \"enum\")) continue\n\t\t\tthrow new SyntaxError(`Fields of type map cannot use ${field.map.from} as a key value, please use an enum, integer, or string type (${MAP_KEY_TYPES.join(', ')} + enum)`)\n\t\t}\n\t}\n\textend: for (const ext of schema.extends) for (const msg of schema.messages) if (msg.name === ext.name) for (const field of ext.fields) {\n\t\tif (!msg.extensions || field.tag < msg.extensions.from || field.tag > msg.extensions.to)\n\t\t\tthrow new ReferenceError(`${msg.name} does not declare ${field.tag} as an extension number`)\n\n\t\tmsg.fields.push(field)\n\t}\n\tpacked: for (const msg of find_lookups(schema, \"message\")) for (const field of msg.fields) if (field.packed && !PACKABLE_TYPES.includes(field.type)) {\n\t\t// check enum type\n\t\tlet type = find_lookup(schema, field.type, \"enum\")\n\t\tif (type) continue\n\t\telse if (field.type.includes('.')) {\n\t\t\tconst types = field.type.split('.')\n\t\t\tlet last = types.pop()!\n\t\t\tlet curr = find_lookup(schema, last, \"enum\")\n\t\t\tif (curr) while (types.length && curr) {\n\t\t\t\tlast = `${types.pop()!}.${last}`\n\t\t\t\tlet c = find_lookup(schema, last, \"enum\")\n\t\t\t\tif (c && curr !== c) curr = c\n\t\t\t}\n\n\t\t\tif (!curr)\n\t\t\t\tthrow new ReferenceError(`Cannot find field type ${field.type}`)\n\n\t\t\tif (curr) continue\n\t\t}\n\t\telse if (msg.enums.some(en => en.name === field.type)) continue;\n\t\telse if (schema.enums.some(en => en.name === field.type)) continue;\n\n\t\tthrow new SyntaxError(`Fields of type ${field.type} cannot be declared [packed=true]. Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire types) can be declared as \"packed\". See https://developers.google.com/protocol-buffers/docs/encoding#optional`)\n\t}\n\tif (schema.package) {\n\t\tconst exp: Lookup = []\n\t\tfor (const {is, value, name} of lu) if (\n\t\t\t// top-level lookup only\n\t\t\tschema.enums.includes(value as Enum)\n\t\t\t|| schema.messages.includes(value as Message)\n\t\t\t|| schema.extends.includes(value as Extends)\n\t\t\t) exp.push({ is, value, name: `${schema.package}.${name}` })\n\t\tlu.push(...exp)\n\t}\n\treturn schema\n}\nexport default parse\n"]}