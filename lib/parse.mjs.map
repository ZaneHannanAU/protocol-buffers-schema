{"version":3,"file":"parse.js","sourceRoot":"","sources":["../src/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import { tokenise } from \"./tokenise\";\nimport { PACKABLE_TYPES, TokenCount, on_syntax_version, on_package_name, on_enum, on_message, on_option, on_import, on_extend, on_service, Lookup, Enum, Message, Extends, MAP_KEY_TYPES, LookupIn, PRIMITIVE_TYPES } from \"./parser-internals\";\nimport { Schema } from \"./schema\";\nexport { Schema } from \"./schema\";\nconst exported_lookups = new WeakMap<Schema, Lookup>();\nexport function find_lookup(s: Schema, name: string, is: \"enum\"): Enum | undefined\nexport function find_lookup(s: Schema, name: string, is: \"message\"): Message | undefined\nexport function find_lookup(s: Schema, name: string, is: \"extends\"): Extends | undefined\nexport function find_lookup(schema: Schema, fname: string, fis: \"enum\" | \"message\" | \"extends\") {\n\tlet v = exported_lookups.get(schema)!\n\t.find(({is, name}) => is === fis && fname === name)\n\tif (!v) return undefined\n\tswitch (fis) {\n\t\tcase \"enum\": return v.value as Enum;\n\t\tcase \"message\": return v.value as Message;\n\t\tcase \"extends\": return v.value as Extends;\n\t}\n}\nexport function find_lookups(schema: Schema, is: \"enum\"): IterableIterator<Enum>\nexport function find_lookups(schema: Schema, is: \"message\"): IterableIterator<Message>\nexport function find_lookups(schema: Schema, is: \"extends\"): IterableIterator<Extends>\nexport function find_lookups(schema: Schema, is?: \"any\"): IterableIterator<LookupIn<\"message\" | \"enum\" | \"extends\">>\nexport function* find_lookups(schema: Schema, fis: \"enum\" | \"message\" | \"extends\" | \"any\" = 'any') {\n\tlet prev = new WeakSet\n\tif (fis === \"any\") yield* exported_lookups.get(schema)!\n\telse for (const {is, value} of exported_lookups.get(schema)!)\n\t\tif (is === fis && !prev.has(value)) {prev.add(value); yield value}\n}\nconst parents_tree = new WeakMap<Enum | Message, Message | Schema>();\nfunction build_parenting_tree(root: Message | Schema) {\n\tfor (const msg of root.messages) if (!parents_tree.has(msg)) {\n\t\tbuild_parenting_tree(msg)\n\t\tparents_tree.set(msg, root)\n\t}\n\tfor (const enm of root.enums) if (!parents_tree.has(enm))\n\t\tparents_tree.set(enm, root)\n}\nexport function* ancestors_of(child: Enum | Message) {\n\tlet ancestor = parents_tree.get(child)\n\twhile (ancestor) {\n\t\tif (ancestor instanceof Schema) break\n\t\tyield ancestor\n\t\tancestor = parents_tree.get(child)\n\t}\n}\ninterface ToString {toString(): string;}\nexport function parse<T extends ToString>(from: T) {\n\tconst schema = new Schema\n\tconst lu: Lookup = []\n\texported_lookups.set(schema, lu)\n\tschema_parse: {\n\t\tconst tc = new TokenCount(Object.freeze(tokenise(from.toString())))\n\t\twhile (!tc.done) switch (tc.peek()) {\n\t\t\tcase 'syntax':\n\t\t\t\tif (tc.t !== 0)\n\t\t\t\t\ttc.syntax_err('Protobuf syntax version must be first token in file');\n\t\t\t\ton_syntax_version(schema, tc);\n\t\t\t\tbreak;\n\t\t\tcase 'package': on_package_name(schema, tc); break;\n\t\t\tcase 'enum': on_enum(schema, tc, lu); break;\n\t\t\tcase 'message': on_message(schema, tc, lu); break;\n\t\t\tcase 'option':\n\t\t\t\ton_option(schema, tc);\n\t\t\t\tif (schema.options.has(\"optimize_for\")) {\n\t\t\t\t\tlet optimize_for = schema.options.get(\"optimize_for\")\n\t\t\t\t\tswitch (optimize_for) {\n\t\t\t\t\t\tcase 'SPEED': case 'CODE_SIZE': case 'LITE_RUNTIME':\n\t\t\t\t\t\t\tschema.optimize_for = optimize_for;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'import': on_import(schema, tc); break;\n\t\t\tcase 'extend': on_extend(schema, tc, lu); break;\n\t\t\tcase 'service': on_service(schema, tc); break;\n\t\t\tdefault: throw new SyntaxError(`Unexpected token: ${tc.next()}`)\n\t\t}\n\t}\n\tbuild_parenting_tree(schema)\n\tmap_types: for (const {value} of lu) {\n\t\tif (value instanceof Message || value instanceof Extends) for (const field of value.fields) if (field.map) {\n\t\t\tif (MAP_KEY_TYPES.has(field.map.from) ||\n\t\t\t\tfind_lookup(schema, field.map.from, \"enum\")) continue\n\t\t\tthrow new SyntaxError(`Fields of type map cannot use ${field.map.from} as a key value, please use an enum, integer, or string type (int32, int64, uint32, uint64, sint32, sint64, bool, fixed64, sfixed64, fixed32, sfixed32, string + enum)`)\n\t\t}\n\t}\n\tfor (const ext of schema.extends) for (const msg of schema.messages) if (msg.name === ext.name) for (const field of ext.fields) {\n\t\tif (!msg.extensions || field.tag < msg.extensions.from || field.tag > msg.extensions.to)\n\t\t\tthrow new ReferenceError(`${msg.name} does not declare ${field.tag} as an extension number`)\n\n\t\tmsg.fields.push(field)\n\t}\n\tfor (const msg of find_lookups(schema, \"message\")) fields: for (const field of msg.fields) {\n\t\tif (field.packed && !PACKABLE_TYPES.has(field.type)) {\n\t\t\t// check for enum type\n\t\t\t{\n\t\t\t\tlet type = find_lookup(schema, field.type, \"enum\")!\n\t\t\t\tif (schema.enums.includes(type)) continue fields\n\t\t\t\tfor (const p of ancestors_of(type))\n\t\t\t\t\tif (p.enums.includes(type)) continue fields\n\t\t\t}\n\t\t\tif (field.type.includes('.')) {\n\t\t\t\tconst types = field.type.split('.')\n\t\t\t\tlet last = types.pop()!\n\t\t\t\tlet curr = find_lookup(schema, last, \"enum\")\n\t\t\t\tif (curr) while (types.length && curr) {\n\t\t\t\t\tlast = `${types.pop()!}.${last}`\n\t\t\t\t\tlet c = find_lookup(schema, last, \"enum\")\n\t\t\t\t\tif (c && curr !== c) curr = c\n\t\t\t\t}\n\n\t\t\t\tif (curr) continue\n\t\t\t\telse throw new ReferenceError(`Cannot find field type ${field.type}`)\n\t\t\t}\n\t\t\telse if (msg.enums.some(en => en.name === field.type)) continue;\n\t\t\telse if (schema.enums.some(en => en.name === field.type)) continue;\n\n\t\t\tthrow new SyntaxError(`Fields of type ${field.type} cannot be declared [packed=true]. Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire types) can be declared as \"packed\". See https://developers.google.com/protocol-buffers/docs/encoding#optional`)\n\t\t}\n\t\tif (!PRIMITIVE_TYPES.has(field.type)) {\n\t\t\tconst types = (\n\t\t\t\tfield.type === 'map' ? field.map!.to : field.type\n\t\t\t).split('.')\n\t\t\tlet last = types.pop()!\n\t\t\tlet curr = find_lookup(schema, last, \"enum\") || find_lookup(schema, last, \"message\")\n\t\t\tif (curr) while (types.length && curr) {\n\t\t\t\tlast = `${types.pop()!}.${last}`\n\t\t\t\tlet c = find_lookup(schema, last, \"enum\") || find_lookup(schema, last, \"message\")\n\t\t\t\tif (c && curr !== c) curr = c\n\t\t\t}\n\n\t\t\tif (curr) field.type_ref = curr // macro for certain purposes\n\t\t}\n\t}\n\tif (schema.package) {\n\t\tconst exp: Lookup = []\n\t\tfor (const {is, value, name} of lu) if (\n\t\t\t// top-level lookup only\n\t\t\tschema.enums.includes(value as Enum)\n\t\t\t|| schema.messages.includes(value as Message)\n\t\t\t|| schema.extends.includes(value as Extends)\n\t\t\t) exp.push({ is, value, name: `${schema.package}.${name}` })\n\t\tlu.push(...exp)\n\t}\n\treturn schema\n}\nexport default parse\n"]}