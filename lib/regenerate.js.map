{"version":3,"file":"regenerate.js","sourceRoot":"","sources":["../src/regenerate.ts"],"names":[],"mappings":";;AAAA,2BAAkG;AAClG,+BAAwC;AACxC,mCAA+B;AAC/B,mCAA8D;AAE9D,MAAM,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAA;AACvC,KAAK,MAAM,IAAI,IAAI,IAAI,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,gBAAQ,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,eAAQ,CAAC,eAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;IAAE,IAAI;QACrH,MAAM,GAAG,GAAG,cAAO,CAAC,eAAe,EAAE,IAAI,CAAC,CAAA;QAC1C,MAAM,MAAM,GAAG,aAAK,CAAC,iBAAS,CAAC,GAAG,GAAG,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAA;QACvD,MAAM,cAAc,GAAG,MAAM,CAAC,MAAM,EAAE,CAAA;QACtC,IAAI,GAAG,GAAG,KAAK,EAAE,MAAM,GAAG,KAAK,CAAA;QAC/B,IAAI;YACH,MAAM,QAAQ,GAAG,iBAAS,CAAC,GAAG,GAAG,OAAO,EAAE,MAAM,CAAC,CAAA;YACjD,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAA;YACjC,wBAAiB,CAAC,cAAc,EAAE,IAAI,CAAC,CAAA;SACvC;QAAC,OAAO,CAAC,EAAE;YACX,IAAI,CAAC,CAAC,IAAI,KAAK,QAAQ;gBAAE,MAAM,GAAG,IAAI,CAAA;YACtC,IAAI,CAAC,CAAC,IAAI,KAAK,eAAe;gBAAE,GAAG,GAAG,IAAI,CAAA;YAC1C,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;SAChB;QACD,IAAI,GAAG,IAAI,MAAM,EAAE;YAClB,IAAI,GAAG,EAAE;gBACR,MAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,cAAc,EAAE,IAAI,EAAE,CAAC,CAAC,CAAA;gBAC5D,kBAAU,CACT,GAAG,GAAG,OAAO,EACb,YAAY,EACZ,MAAM,CACN,CAAA;gBACD,OAAO,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,MAAM,IAAI,OAAO,CAAC,CAAA;aAC3D;;gBAAM,OAAO,CAAC,GAAG,CAAC,SAAS,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,KAAK,IAAI,OAAO,CAAC,CAAA;SACvE;aAAM;YACN,OAAO,CAAC,GAAG,CAAC,QAAQ,IAAI,kBAAkB,CAAC,CAAA;SAC3C;KACD;IAAC,OAAO,CAAC,EAAE;QACX,OAAO,CAAC,GAAG,CAAC,8BAA8B,EAAE,IAAI,EAAE,CAAC,CAAC,CAAA;KACpD","sourcesContent":["import {readFileSync as read_file, writeFileSync as write_file, readdirSync as read_dir} from 'fs'\nimport { basename, resolve } from 'path'\nimport { parse } from './parse'\nimport { deepStrictEqual as deep_strict_equal } from \"assert\";\n\nconst owr = process.argv.includes('-y')\nfor (const file of new Set(Array.from(read_dir('test/fixtures'), v => basename(basename(v, '.proto'), '.json')))) try {\n\tconst pos = resolve('test/fixtures', file)\n\tconst schema = parse(read_file(pos + '.proto', 'utf8'))\n\tconst schema_to_json = schema.toJSON()\n\tlet neq = false, enoent = false\n\ttry {\n\t\tconst json_str = read_file(pos + '.json', 'utf8')\n\t\tconst json = JSON.parse(json_str)\n\t\tdeep_strict_equal(schema_to_json, json)\n\t} catch (e) {\n\t\tif (e.code === 'ENOENT') enoent = true\n\t\tif (e.code === 'ERR_ASSERTION') neq = true\n\t\tconsole.error(e)\n\t}\n\tif (neq || enoent) {\n\t\tif (owr) {\n\t\t\tconst json_str_new = JSON.stringify(schema_to_json, null, 2)\n\t\t\twrite_file(\n\t\t\t\tpos + '.json',\n\t\t\t\tjson_str_new,\n\t\t\t\t'utf8'\n\t\t\t)\n\t\t\tconsole.log(`${enoent ? 'Creat' : 'Chang'}ed ${file}.json`)\n\t\t} else console.log(`Would ${enoent ? \"creat\" : \"chang\"}e ${file}.json`)\n\t} else {\n\t\tconsole.log(`File ${file} has no changes.`)\n\t}\n} catch (e) {\n\tconsole.log(\"%s gives error %O on parsing\", file, e)\n}\n"]}